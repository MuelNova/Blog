---
title: 2024 保研夏令营机试刷题记录
authors: [nova]
---

刷 leetcode 还是没什么意思，准备一天来一套真题（笑，不做特别难的题和特别麻烦的大模拟，确保做题速度。

会按照一个顺序选择刷题。

<!--truncate-->

# PKU

## 2023 研究生推免 （5/14）

### 全在其中

> A:全在其中
>
> 总时间限制: 1000ms 内存限制: 65536kB
> 描述
> 你设计了一个新的加密技术，可以用一种聪明的方式在一个字符串的字符间插入随机的字符串从而对信息进行编码。由于专利问题，我们将不会详细讨论如何在原有信息中产生和插入字符串。不过，为了验证你的方法，有必要写一个程序来验证原来的信息是否全在最后的字符串之中。
>
> 给定两个字符串s和t，你需要判断s是否是t的“子列”。也就是说，如果你去掉t中的某些字符，剩下字符将连接而成为s。
>
> 
>
> 输入
> 输入包括多个测试样例。每一个都是由空格分隔的由字母数字ASCII字符组成的两个特定的字符串s和t。s和t的长度不超过100000。
>
> 输出
> 对于每个测试样例，如果s是t的“子列”，则输出”Yes”，否则输出”No”

签到题。双指针扫一遍即可。

```cpp
#include <iostream>
#include <string>

using namespace std;

int n;

bool isSub(string str, string sub) {
    int i = 0, l = 0;
    while (i < sub.size() && l < str.size()) {
        if (str[l] == sub[i]) i++, l++;
        else l++;
    }
    return i == sub.size();
}


int main() {
    string substr, str;
        
    while (cin >> substr >> str) {
        cout << (isSub(str, substr) ? "Yes" : "No" ) << endl;
    }
}
```

### 最接近的分数

> B:最接近的分数
> 总时间限制: 1000ms 内存限制: 65536kB
> 描述
>
> 分母不超过 N 且 小于 A/B 的最大最简分数是多少？
>
> 输入
>
> 三个正整数N，A，B，相邻两个数之间用单个空格隔开。$1 \le A < B < N \le 1000$。
>
> 输出
>
> 两个正整数，分别是所求分数的分子和分母，中间用单个空格隔开。

从 1~N 扫一遍，选择分子和分母。因为 $N \le 1000$，所以 $O(n^2)$ 可以接受。

注意就是用乘法防止除法精度问题。最大 1000*1000，爆不了 int

```cpp
#include <iostream>
using namespace std;

int n, a, b;


int main() {
    cin >> n >> a >> b;
    // 分母小于等于 n，小于 a / b
    int mxi = -1, mxj = -1;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            // j/i
            if (j*b < a *i) {
                if (mxi == -1 || mxj == -1 || j * mxi > mxj * i) mxj = j, mxi = i;
            }
        }
    }
    cout << mxj << " " << mxi << endl;
}
```

### 踩方格

> 踩方格
>
> 总时间限制: 1000ms 内存限制: 65536kB
> 描述
>
> 有一个方格矩阵，矩阵边界在无穷远处。我们做如下假设：
> a.    每走一步时，只能从当前方格移动一格，走到某个相邻的方格上；
> b.    走过的格子立即塌陷无法再走第二次；
> c.    只能向北、东、西三个方向走；
>
> 请问：如果允许在方格矩阵上走n步，共有多少种不同的方案。2种走法只要有一步不一样，即被认为是不同的方案。
>
> 输入
> 允许在方格上行走的步数n(n \le 20)
>
> 输出
> 计算出的方案数量

一眼 DP 或者 dfs，用 DFS 写的回溯，最多运行 20 * 3 次。这里开了个 41 * 21 的数组，然后从 20 开始走，数组用于判断走没走过。

```cpp
#include <iostream>

using namespace std;

int mat[42][21];
int res;
int n;

int dx[3] = {0, 1, 0};
int dy[3] = {-1, 0, 1};

void dfs(int x, int y, int u) {
    if (u == n) {
        res ++;
        return;
    }
    
    for (int i = 0; i < 3; i++) {
        int xx = x + dx[i];
        int yy = y + dy[i];

        if (mat[xx][yy]) continue;
        mat[xx][yy] = 1;
        dfs(xx, yy, u + 1);
        mat[xx][yy] = 0;
    }
}

int main() {
    cin >> n;
    mat[20][0] = 1;
    dfs(20, 0, 0);
    cout << res;
}
```

### 核电站

> D:核电站
>
> 总时间限制: 5000ms 单个测试点时间限制: 1000ms 内存限制: 131072kB
> 描述
> 一个核电站有 N 个放核物质的坑，坑排列在一条直线上。如果连续 M 个坑中放入核物质，则会发生爆炸，于是，在某些坑中可能不放核物质。
>
> 任务：对于给定的 N 和 M ，求不发生爆炸的放置核物质的方案总数。
>
> 输入
> 只有一行，两个正整数 N，M (1 < N < 50, $2 \le M \le 5$)。
>
> 输出
> 一个正整数 S，表示方案总数。

2 \le M \le 5最卡的一题。一开始也用了一个 DFS，每个位置摆和不摆两种。写完发现是 $O(2^n)$ 的复杂度，寄！不过如果真遇到应该可以骗几个测例的分。

选择 DP，一开始写了一个二维 DP，但是一直没有想清楚转移方程。

$f\[i]\[j]$ 代表到 i 位置合法的个数，j 是二维的，代表第 i 位置放或者不放。对于 i < m 的情况，直接加就完事了；对于 i == m 的情况，减掉第一个位置放的一种情况；对于 i > m 的情况，这里一直没想清楚，后面突然理解了，我们要去掉的情况是明朗的：i-m+1 ~ i 共 m - 1 个位置都放，i-m 这个位置不放，而对于前面 i-m-1 个位置，我们怎么放都可以，因此不合法的个数是 1 * f[i-m-1] 个。

然后就是要注意爆 int 的问题，假设 m 不存在，那么我们就有 2^n 个方案，就算有 m 这个限制条件，也不会减特别多，所以用 long long 最保险。

```c++
/* O(2^n) */

void dfs(int x, int u, int p) {
    // u 当前已放置的个数
    // x 当前放置的位置
    // p 当前连续放置多少个
    if (p >= m) return;

    if (x == n) {
        res ++;
        return;
    }

    dfs(x + 1, u, 0);  // 不在这里放
    dfs(x + 1, u + 1, p + 1);  // 在这里放

    return;
}
```

```cpp
long long f[55];

int main() {
    cin >> n >> m;

    // f[i][0/1] 代表在 i 位置放和不放的总数情况 (合法的)
    // f[n][0] + f[n][1]
    // f[i][0] = f[i-1][0] + f[i-1][1]
    // f[i][1] = f[i-1][0] + f[i-1][1] - 不合法方案
    
    // 对于 i == m 的情况，我们仅需减去一种方案，即全放的方案
    // 对于 i > m 的情况，我们需要减去的是这样一种方案：i-m+1~i 共 m - 1 个位置都放，i-m 没有放。但是 i - m - 1 前的方案是不确定的，因此乘法原理处理。


    f[0][0] = 1;
    for (int i = 1; i < m; i++) f[i][1] = f[i][0] = f[i-1][0] + f[i-1][1];
    for (int i = m; i <= n;) {
        f[i][0] = f[i-1][0] + f[i-1][1];
        f[i][1] = f[i-1][0] + f[i-1][1] - 1;
        break;
    }
    for (int i = m + 1; i <= n; i++) {
        f[i][0] = f[i-1][0] + f[i-1][1];
        f[i][1] = f[i-1][0] + f[i-1][1] - f[i-1-m][1] - f[i-1-m][0];
    }

    cout << f[n][0] + f[n][1];
}
```



之后，可以发现其实我们用一维合并一下更好。

```cpp
long long f[55];

int main() {
    cin >> n >> m;	
	// 可以发现我们能够压缩一维
    // f[i][1] + f[i][0] = 2*(f[i-1][0] + f[i-1][1]) - 不合法方案

    f[0] = 1;
    for (int i = 1; i <= n; i++) {
        f[i] = 2 * f[i-1];
        if (i == m) f[i] -= 1;
        if (i > m) f[i] -= f[i-1-m];
    }

    cout << f[n];
    
}
```



### Highways

> G:Highways
> 总时间限制: 1000ms 内存限制: 65536kB
> 描述
> The island nation of Flatopia is perfectly flat. Unfortunately, Flatopia has no public highways. So the traffic is difficult in Flatopia. The Flatopian government is aware of this problem. They're planning to build some highways so that it will be possible to drive between any pair of towns without leaving the highway system.
>
> Flatopian towns are numbered from 1 to N. Each highway connects exactly two towns. All highways follow straight lines. All highways can be used in both directions. Highways can freely cross each other, but a driver can only switch between highways at a town that is located at the end of both highways.
>
> The Flatopian government wants to minimize the length of the longest highway to be built. However, they want to guarantee that every town is highway-reachable from every other town.
>
> 输入
> The first line of input is an integer T, which tells how many test cases followed.
> The first line of each case is an integer N ($3 \le N \le 500$), which is the number of villages. Then come N lines, the i-th of which contains N integers, and the j-th of these N integers is the distance (the distance should be an integer within [1, 65536]) between village i and village j. There is an empty line after each test case.
>
> 输出
> For each test case, you should output a line contains an integer, which is the length of the longest road to be built such that all the villages are connected, and this value is minimum.

概括一下题意，就是说要建高速，从 1~n 个点之间两两建，输出可以修建的方案里最长高速最小的距离。其实翻译一下就是找最小生成树。这里也有贪心性质，可以证明下。假设现在有一颗最小生成树，它的边权值最大为 x，假设存在另一颗生成树，其边权值最大为 y，且满足 x > y，由于两两连通，那么一定通过这条权值边生成一个更小的生成树，矛盾，因此最小生成树的边权值最大即为题目所要求的。



理解之后就是 Prim 或者 KRUSKAL 的板子题了。注意读入的时候，它到自身的边权值为 0，改成无穷大就好。

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

int n;

void prim(vector<vector<int>>& mat) {
    vector<int> dist(mat.size(), 0x3f3f3f3f);
    vector<bool> st(mat.size(), false);

    dist[1] = 0;
    int res = INT_MIN;
    for (int i = 1; i < mat.size(); i++) {
        int v = -1;
        for (int j = 1; j < mat.size(); j++) if (!st[j] && (v == -1 || dist[j] < dist[v] )) v = j;

        st[v] = true;

        res = max(res, dist[v]);

        for (int j = 1; j < mat.size(); j++) {
            if (!st[j] && dist[j] > mat[v][j]) dist[j] = mat[v][j];
        }
    }

    cout << res << endl;
}

int main() {
    scanf("%d", &n);
    
    while (n--) {
        string tmp;
        getline(cin, tmp);
        int m;
        scanf("%d", &m);
        vector<vector<int>> mat(m + 1, vector<int>(m + 1));

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= m; j ++) {
                scanf("%d", &mat[i][j]);
                if (i == j) mat[i][j] = 0x3f3f3f3f;
            }
        }
        prim(mat);
    }
}
```

## 2023 研究生上机 （5/15）

### 寻找特殊年号

> A:寻找特殊年号
>
> 查看提交统计提问
>
> 总时间限制: 1000ms 内存限制: 65535kB
>
> 描述
>
> 年号中的每个数之和为20的年号是特殊年号。例如：2099、1991、1892是特殊的年号，而2021则不是。给定一个年号，找出严格大于给定年号的最小特殊年号。
>
> 输入
>
> 年号：整数y(1000≤y≤9000)。
>
> 输出
>
> 特殊年号：严格意义上大于y的最小年号，并且它的每个数之和为20。

不知道有没有更聪明的做法，一开始是直接每个往上找，感觉会 TLE，就首先存了特殊的，然后二分去找第一个大于当前的。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<int> spe;

int getSum(int i) {
    int sum = 0;
    while (i) {
        sum += i % 10;
        i /= 10;
    }
    return sum;
}

void gen() {
    for (int i = 1000; i < 10000; i++) {
        if (getSum(i) == 20) spe.push_back(i);
    }
    sort(spe.begin(), spe.end());
}

int main() {
    gen();
    int n;
    while (cin >> n) {
        auto nxt = upper_bound(spe.begin(), spe.end(), n);
        cout << *nxt << endl;
    }
}
```



### 图像模糊处理

> B:图像模糊处理
>
> 查看提交统计提问
>
> 总时间限制: 1000ms 内存限制: 65536kB
>
> 描述
>
> 给定n行m列的图像各像素点的灰度值，要求用如下方法对其进行模糊化处理：
>
> 1. 四周最外侧的像素点灰度值不变；
> 2. 中间各像素点新灰度值为该像素点及其上下左右相邻四个像素点原灰度值的平均（舍入到最接近的整数）。
>
> 输入
>
> 第一行包含两个整数n和m，表示图像包含像素点的行数和列数。1 ≤ n ≤ 100，1 ≤ m ≤ 100。
>
> 接下来n行，每行m个整数，表示图像的每个像素点灰度。相邻两个整数之间用单个空格隔开，每个元素均在0~255之间。
>
> 输出
>
> n行，每行m个整数，为模糊处理后的图像。相邻两个整数之间用单个空格隔开。

没看懂，直接做就完了？

```cpp
#include <iostream>
#include <vector>
using namespace std;


int n, m;
int mat[110][110];


int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            scanf("%d", &mat[i][j]);
        }
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (i == 1 || i == n || j == 1 || j == m) {
                cout << mat[i][j];
                if (i == n && j == m) continue;
                if (j == m) cout << endl;
                else cout << " ";
                continue;
            }
            int sum = mat[i-1][j] + mat[i][j] + mat[i+1][j] + mat[i][j-1] + mat[i][j+1];
            cout << sum / 5 << " ";
        }
    }
}
```

### 括号生成

> C:括号生成
>
> 查看提交统计提问
>
> 总时间限制: 1000ms 内存限制: 65536kB
>
> 描述
>
> Paul是一名数学专业的同学，在课余选修了C++编程课，现在他能够自己写程序判断判断一个给定的由'('和')'组成的字符串是否是正确匹配的。可是他不满足于此，想反其道而行之，设计一个程序，能够生成所有合法的括号组合，请你帮助他解决这个问题。
>
> 输入
>
> 输入只有一行N，代表生成括号的对数（1 ≤ N ≤ 10)。
>
> 输出
>
> 输出所有可能的并且有效的括号组合，按照字典序进行排列，每个组合占一行。

dfs，让左括号数量大于右括号即可。



```cpp
#include <iostream>
#include <vector>
using namespace std;

int n;
vector<char> res;

void dfs(int l, int r, int u) {
    if (l > n || r > n || r > l) return;
    if (u == 2*n) {
        for (auto i : res) {
            cout << i;
        }
        cout << endl;
        return;
    }

    res.push_back('(');
    dfs(l + 1, r, u + 1);
    res.pop_back();

    res.push_back(')');
    dfs(l, r + 1, u + 1);
    res.pop_back();
    
}

int main() {
    cin >> n;
    dfs(0, 0, 0);
}
```



### 有多少种二叉树

> D:有多少种二叉树
>
> 查看提交统计提问
>
> 总时间限制: 1000ms 内存限制: 65536kB
>
> 描述
>
> 输入n(1<n<13)，求n个结点的二叉树有多少种形态
>
> 输入
>
> 整数n
>
> 输出
>
> 答案

卡特兰数

```cpp
#include <iostream>
using namespace std;

int n;

long long C(int n, int m) {
    long long res = 1, p = 1;
    for (int i = n, j = 1; j <= m; i--, j++) {
        res *= i;
        p *= j;
    }

    return res / p;
}

int main() {
    cin >> n;
    cout <<  C(2*n, n) / (n + 1) << endl;
}
```



### 酒鬼

> E:酒鬼
>
> 查看提交统计提问
>
> 总时间限制: 2000ms 单个测试点时间限制: 1000ms 内存限制: 131072kB
>
> 描述
>
> Santo 刚刚与房东打赌赢得了一间在 New Clondike 的大客厅。今天，他来到这个大客厅欣赏他的奖品。房东在酒吧上摆了一排瓶子，瓶子里都装有不同体积的酒。令 Santo 高兴的是，瓶子中的酒都有不同的味道。房东说道：“你可以喝尽可能多的酒，但是一旦打开酒盖你就必须把它喝完，喝完一瓶后把它放回原处。还有一件最重要的事，你必须从左至右依次喝，但不能连续三瓶或以上，不然会给你带来坏运气。” 现在可怜的 Santo 站在酒吧前努力地想着，他到底应该喝哪几瓶才能使喝的酒最多呢？请帮助他找出他应该喝的酒瓶号，因为思考让他感到不安。
>
> 输入
>
> 第一行一个整数 N (1≤N≤700) 表示有 N 个酒瓶。接下有 N 行，第 i+1 行的整数 Ai (1≤Ai≤10000) 代表酒瓶 i 中酒的体积。
>
> 输出
>
> 一个整数，表示 Santo 能喝的酒的最大总体积。遵守以上规则，使得任意连续三个瓶子中至少一个瓶子是满的。

一个动态规划，当时写了注释了就不说了。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int n;
int s[710];
int f[710];

int main() {
    // f[i] 代表喝的体积的集合
    // max
    // f[i] 满足最多喝连续两瓶，因此对于 f[i+1]，我们不能喝，才能确保合法。
    // f[i] 仅与包含 i 的前三个有关即可处理。
    // f[i] = f[i-3] + 连续喝 i-1 和 i
    //      = f[i-2] + 只喝 i
    //      = f[i-1] + 不喝
    cin >> n;
    for (int i = 1; i <= n; i++) scanf("%d", &s[i]);
    f[0] = 0;
    for (int i = 1; i <= n; i++) {
        if (i <= 2) f[i] = f[i-1] + s[i];
        f[i] = max({f[i-3] + s[i-1] + s[i], f[i-2] + s[i], f[i-1]});
    }
    cout << f[n] << endl;
}
```

### 最短路

> F:最短路
>
> 查看提交统计提问
>
> 总时间限制: 2000ms 内存限制: 65536kB
>
> 描述
>
> 给定一个n个点, m条边的有向图, 求从点S出发, 到其它所有点的最短路径.
>
> 输入
>
> 第一行一个整数T, 表示有T组数据
>
> 对于每组测试数据, 第一行三个整数n, m, S, 表示有n个点, m条边, 起点为S.
>
> 接下来m行, 每行三个整数x, y, z, 代表从x到y有长度为z的边
>
> 点的编号从1到n
>
> T ≤ 10, n ≤ 10000, m ≤ 20000, |z| ≤ 10000. 所有数据的n之和 ≤ 30000, 所有数据的m之和 ≤ 60000.
>
> 输出
>
> 对于每组数据:
>
> 如果从S点出发可以走入负圈 (即到某些点的最短路径可以无限小), 那么输出一行Error.
>
> 否则, 输出一行用空格分隔的n个整数, 其中第i个整数表示从S点到i点的最短路长度. 如果从S点无法到达i点, 则第i个输出为”null”.

模板题，有负权回路，走 spfa 就好

```cpp
#include <iostream>
#include <queue>
#include <cstring>
using namespace std;
typedef pair<int, int> PII;

const int N = 2e4 + 10;

int e[N], ne[N], w[N], h[N];
int idx;
int T, n, m, S;

void add(int a, int b, int weight) {
    e[++idx] = b;
    ne[idx] = h[a];
    h[a] = idx;
    w[idx] = weight;
}

void spfa(int S) {
    queue<PII> q;
    vector<int> dist(N, 0x3f3f3f3f), cnt(N, 0);
    vector<bool> st(N, false);
    q.push({0, S});  // dist, node;
    dist[S] = 0;
    while(q.size()) {
        auto &[d, nn] = q.front();
        q.pop();
        
        st[nn] = false;
        for (int i = h[nn]; i; i = ne[i]) {
            int j = e[i];
            if (dist[j] > dist[nn] + w[i]) {
                dist[j] = dist[nn] + w[i];
                cnt[j] = cnt[nn] + 1;
                if (cnt[j] >= n) {
                    cout << "Error" << endl;
                    return;
                }
                if (!st[j]) {
                    st[j] = true;
                    q.push({dist[j], j});
                }
            }
        }
    }

    for (int i = 1; i <= n; i++) {
        if (dist[i] > 0x3f3f3f3f / 2) cout << "null";
        else cout << dist[i];
        cout << " ";
    }
    cout << endl;
}

int main() {
    cin >> T;
    while (T--) {
        memset(e, 0, sizeof e);
        memset(ne, 0, sizeof ne);
        memset(w, 0, sizeof w);
        memset(h, 0, sizeof h);
        idx = 0;
        cin >> n >> m >> S;

        for (int i = 0; i < m; i++) {
            int a, b, c;
            cin >> a >> b >> c;
            add(a, b, c);
        }
        spfa(S);
    }
}
```

### 摆放玩具

> G:玩具摆放
>
> 查看提交统计提问
>
> 总时间限制: 10000ms 单个测试点时间限制: 1000ms 内存限制: 524288kB
>
> 描述
>
> 在一个4*4的方框内摆放了若干个相同的玩具。
>
> 某人想通过移动玩具，将这些玩具重新摆放成为他心中理想的状态。要求每次移动时，只能将某一个玩具向上下左右四个方向之一移动一步。不能将玩具移出方框，并且移动的目标位置不能已经放置有玩具。
>
> 请你用最少的移动次数将初始的玩具状态移动到他心中的目标状态。
>
> 输入
>
> 前4行表示玩具的初始状态，每行4个数字1或0，1表示方格中放置了玩具，0表示没有放置玩具。
>
> 接着是一个空行。接下来4行表示玩具的目标状态，每行4个数字1或0，意义同上。
>
> 输出
>
> 一个整数，所需要的最少移动次数。保证初始状态可以达到目标状态。
>
> 提示
>
> 可以考虑将玩具局面表示为一个16 bit的整数，设置一个标志数组用来判重，用这个整数做下标找其对应标志位

根据提示，用 BFS 来做，一个 set 用于存。

位运算稍微处理了一下

```cpp
#include <iostream>
#include <unordered_set>
#include <vector>
#include <queue>
#include <string>

using namespace std;

int dx[4] = {-1, 1, 0, 0};
int dy[4] = {0, 0, -1, 1};

void bfs(int raw, int res) {
    unordered_set<int> set;
    queue<pair<int, int>> q;
    set.insert(raw);
    q.push({raw, 0});
    while (!q.empty()) {
        auto &[now, cnt] = q.front();
        q.pop();

        if (now == res) {
            cout << cnt << endl;
            return;
        }

        for (int i = 15; i >= 0; i--) {
            if ((now >> i) & 1) {
                int x = (15-i) % 4;
                int y = (15-i) / 4;
                
                for (int k = 0; k < 4; k++) {
                    int xx = x + dx[k];
                    int yy = y + dy[k];
                    
                    if (xx < 0 || xx > 3 || yy < 0 || yy > 3) continue;
                    int l = 15 - 4*yy - xx;
                    if ((now >> l) & 1) continue;
                    int nxt = (now ^ (1 << i)) | (1 << l);
                    if (set.count(nxt)) continue;
                    set.insert(nxt);
                    q.push({nxt, cnt + 1});
                }
            }
        }
    }
}

int main() {
    int raw = 0;
    int res = 0;
    for (int i = 0; i < 4; i++) {
        string tmp;
        cin >> tmp;
        for (auto c : tmp) {
            raw <<= 1;
            raw |= c-'0';
        }
    }
    for (int i = 0; i < 4; i++) {
        string tmp;
        cin >> tmp;
        for (auto c : tmp) {
            res <<= 1;
            res |= c-'0';
        }
    }
    bfs(raw, res);
}
```

## 2019 研究生推免（5/15）

感觉这次很简单。

### 有趣的跳跃

> A:有趣的跳跃
>
> 查看提交统计提问
>
> 总时间限制: 1000ms 内存限制: 65536kB
>
> 描述
>
> 一个长度为n（n>0）的序列中存在“有趣的跳跃”当前仅当相邻元素的差的绝对值经过排序后正好是从1到(n-1)。例如，1 4 2 3存在“有趣的跳跃”，因为差的绝对值分别为3,2,1。当然，任何只包含单个元素的序列一定存在“有趣的跳跃”。你需要写一个程序判定给定序列是否存在“有趣的跳跃”。
>
> 输入
>
> 一行，第一个数是n（0 < n < 3000），为序列长度，接下来有n个整数，依次为序列中各元素，各元素的绝对值均不超过1,000,000,000。
>
> 输出
>
> 一行，若该序列存在“有趣的跳跃”，输出"Jolly"，否则输出"Not jolly"。

签到题，直接判断就完事了。

```cpp
#include <iostream>
#include <cmath>

using namespace std;


int n;

int main() {
    cin >> n;
    int pre = -1;
    int tmp;
    cin >> tmp;
    while (n-- > 1) {
        int tmp2;
        cin >> tmp2;
        if (pre >= 0 && abs(tmp2-tmp) != pre - 1) { cout << "Not jolly" << endl; return 0; }
        pre = abs(tmp2-tmp);
        tmp = tmp2;
    }
    cout << "Jolly" << endl;
    return 0;

```



### 玛雅历

> B:玛雅历
>
> 查看提交统计提问
>
> 总时间限制: 1000ms 内存限制: 65536kB
>
> 描述
>
> 上周末，M.A. Ya教授对古老的玛雅有了一个重大发现。从一个古老的节绳（玛雅人用于记事的工具）中，教授发现玛雅人使用了一个一年有365天的叫做Haab的历法。这个Haab历法拥有19个月，在开始的18个月，一个月有20天，月份的名字分别是pop, no, zip, zotz, tzec, xul, yoxkin, mol, chen, yax, zac, ceh, mac, kankin, muan, pax, koyab, cumhu。这些月份中的日期用0到19表示。Haab历的最后一个月叫做uayet，它只有5天，用0到4表示。玛雅人认为这个日期最少的月份是不吉利的，在这个月法庭不开庭，人们不从事交易，甚至没有人打扫屋中的地板。
>
> 因为宗教的原因，玛雅人还使用了另一个历法，在这个历法中年被称为Tzolkin(holly年)，一年被分成13个不同的时期，每个时期有20天，每一天用一个数字和一个单词相组合的形式来表示。使用的数字是1~13，使用的单词共有20个，它们分别是：imix, ik, akbal, kan, chicchan, cimi, manik, lamat, muluk, ok, chuen, eb, ben, ix, mem, cib, caban, eznab, canac, ahau。注意：年中的每一天都有着明确唯一的描述，比如，在一年的开始，日期如下描述： 1 imix, 2 ik, 3 akbal, 4 kan, 5 chicchan, 6 cimi, 7 manik, 8 lamat, 9 muluk, 10 ok, 11 chuen, 12 eb, 13 ben, 1 ix, 2 mem, 3 cib, 4 caban, 5 eznab, 6 canac, 7 ahau, ，8 imix, 9 ik, 10 akbal ……也就是说数字和单词各自独立循环使用。
>
> Haab历和Tzolkin历中的年都用数字0，1，……表示，数字0表示世界的开始。所以第一天被表示成：
>
> Haab: 0. pop 0
>
> Tzolkin: 1 imix 0
>
> 请帮助M.A. Ya教授写一个程序可以把Haab历转化成Tzolkin历。
>
> 输入
>
> Haab历中的数据由如下的方式表示：
>
> 日期. 月份 年数
>
> 输入中的第一行表示要转化的Haab历日期的数据量。下面的每一行表示一个日期，年数小于5000。
>
> 输出
>
> Tzolkin历中的数据由如下的方式表示：
>
> 天数字 天名称 年数
>
> 第一行表示输出的日期数量。下面的每一行表示一个输入数据中对应的Tzolkin历中的日期。

一个简单的模拟。计算出总天数，然后转换就好。

```cpp
#include <iostream>
#include <string>
#include <unordered_map>
#include <sstream>

using namespace std;

unordered_map<string, int> Haab = {
    {"pop", 0}, 
    {"no", 1}, 
    {"zip", 2}, 
    {"zotz", 3}, 
    {"tzec", 4}, 
    {"xul", 5}, 
    {"yoxkin", 6}, 
    {"mol", 7}, 
    {"chen", 8},
    {"yax", 9}, 
    {"zac", 10},
    {"ceh", 11}, 
    {"mac", 12}, 
    {"kankin", 13}, 
    {"muan", 14}, 
    {"pax", 15}, 
    {"koyab", 16}, 
    {"cumhu", 17}, 
    {"uayet", 18}
};

unordered_map<int, string> Tzolkin = {
    {0, "imix"}, 
    {1, "ik"}, 
    {2, "akbal"}, 
    {3, "kan"}, 
    {4, "chicchan"}, 
    {5, "cimi"}, 
    {6, "manik"}, 
    {7, "lamat"}, 
    {8, "muluk"}, 
    {9, "ok"}, 
    {10, "chuen"}, 
    {11, "eb"}, 
    {12, "ben"}, 
    {13, "ix"}, 
    {14, "mem"}, 
    {15, "cib"}, 
    {16, "caban"}, 
    {17, "eznab"}, 
    {18, "canac"}, 
    {19, "ahau"}
};

int n;

int haab_to_day(string tmp) {
    stringstream ss(tmp);
    int day, year;
    string month;
    ss >> day;
    ss.ignore();
    ss >> month;
    ss >> year;
    return year * 365 + Haab[month] * 20 + day;
}

void day_to_tzolkin(int day) {
    int year = day / 260;
    int day_in_year = day % 260;
    
    int day_num = day_in_year % 13 + 1;
    string day_string = Tzolkin[day_in_year % 20];

    cout << day_num << " " << day_string << " " << year << endl;

}

int main() {
    cin >> n;
    // cin.ignore();
    string tmp;
    getline(cin, tmp);
    cout << n << endl;
    while (n--) {
        getline(cin, tmp);
        int day = haab_to_day(tmp);
        day_to_tzolkin(day);
    }
}
```

### 走迷宫

> C:走迷宫
>
> 查看提交统计提问
>
> 总时间限制: 1000ms 内存限制: 65536kB
>
> 描述
>
> 一个迷宫由R行C列格子组成，有的格子里有障碍物，不能走；有的格子是空地，可以走。
>
> 给定一个迷宫，求从左上角走到右下角最少需要走多少步(数据保证一定能走到)。只能在水平方向或垂直方向走，不能斜着走。
>
> 输入
>
> 第一行是两个整数，Ｒ和Ｃ，代表迷宫的长和宽。（ 1≤ R，C ≤ 40)
>
> 接下来是Ｒ行，每行Ｃ个字符，代表整个迷宫。
>
> 空地格子用'.'表示，有障碍物的格子用'#'表示。
>
> 迷宫左上角和右下角都是'.'。
>
> 输出
>
> 输出从左上角走到右下角至少要经过多少步（即至少要经过多少个空地格子）。计算步数要包括起点和终点。

BFS 模板题感觉是。



```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;


int R, C;
int mat[41][41];
int dx[4] = {0, 0, -1, 1};
int dy[4] = {-1, 1, 0, 0};

void bfs() {
    queue<vector<int>> q;
    q.push({1, 1, 1});
    while (!q.empty()) {
        auto t = q.front();
        int x = t[0], y = t[1], c = t[2];
        q.pop();

        if (x == R && y == C) { cout << c << endl; return; }
        mat[x][y] = 2;
        
        for (int i = 0; i < 4; i++) {
            int xx = x + dx[i];
            int yy = y + dy[i];
            if (xx <= 0 || xx > R || yy <= 0 || yy > C) continue;
            if (!mat[xx][yy]) q.push({xx, yy, c+1});
        }
    }
}

int main() {
    cin >> R >> C;
    char ch;
    for (int i = 1; i <= R; i++) {
        scanf("\r\n");
        for (int j = 1; j <= C; j++) {
            scanf("%c", &ch);
            mat[i][j] = ch == '#';
        }
    }
    bfs();
}
```

### 最大上升子序列和

> D:最大上升子序列和
>
> 查看提交统计提问
>
> 总时间限制: 1000ms 内存限制: 65536kB
>
> 描述
>
> 一个数的序列bi，当b1 < b2 < ... < bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, ...,aN)，我们可以得到一些上升的子序列(ai1, ai2, ..., aiK)，这里1 ≤ i1 < i2 < ... < iK ≤ N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中序列和最大为18，为子序列(1, 3, 5, 9)的和.
>
> 你的任务，就是对于给定的序列，求出最大上升子序列和。注意，最长的上升子序列的和不一定是最大的，比如序列(100, 1, 2, 3)的最大上升子序列和为100，而最长上升子序列为(1, 2, 3)
>
> 输入
>
> 输入的第一行是序列的长度N (1 ≤ N ≤ 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000（可能重复）。
>
> 输出
>
> 最大上升子序列和

第一时间想成了最大上升子序列，不过二者答案是有区别的，转义方程倒是大同小异。

```cpp
#include <iostream>
#include <ostream>
using namespace std;

int n;
int s[1010];
int f[1010];

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) scanf("%d", &s[i]);

    // f[i] 代表子序列和
    // maxx
    // f[i] = max(f[i-k] + (a[i-k] < a[i] ? a[i] : 0))

    int res = -0x3f3f3f3f;
    for (int i = 1; i <= n; i++) f[i] = s[i];
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <i; j++) {
            if (s[i-j] < s[i]) f[i] = max(f[i], f[i-j] + s[i]);
        }
        res = max(res, f[i]);
    }
    cout << res << endl;
    return 0;
}
```



### Yogurt Factory

> E:Yogurt factory
>
> 查看提交统计提问
>
> 总时间限制: 1000ms 内存限制: 65536kB
>
> 描述
>
> The cows have purchased a yogurt factory that makes world-famous Yucky Yogurt. Over the next N (1 ≤ N ≤ 10,000) weeks, the price of milk and labor will fluctuate weekly such that it will cost the company C_i (1 ≤ C_i ≤ 5,000) cents to produce one unit of yogurt in week i. Yucky's factory, being well-designed, can produce arbitrarily many units of yogurt each week.
>
> Yucky Yogurt owns a warehouse that can store unused yogurt at a constant fee of S (1 ≤ S ≤ 100) cents per unit of yogurt per week. Fortuitously, yogurt does not spoil. Yucky Yogurt's warehouse is enormous, so it can hold arbitrarily many units of yogurt.
>
> Yucky wants to find a way to make weekly deliveries of Y_i (0 ≤ Y_i ≤ 10,000) units of yogurt to its clientele (Y_i is the delivery quantity in week i). Help Yucky minimize its costs over the entire N-week period. Yogurt produced in week i, as well as any yogurt already in storage, can be used to meet Yucky's demand for that week.
>
> 输入
>
> \* Line 1: Two space-separated integers, N and S.
>
> \* Lines 2..N+1: Line i+1 contains two space-separated integers: C_i and Y_i.
>
> 输出
>
> \* Line 1: Line 1 contains a single integer: the minimum total cost to satisfy the yogurt schedule. Note that the total might be too large for a 32-bit integer.

看这个数据范围就觉得是贪心，但是居然没有想出来怎么贪心... 在那考虑 A 买几个 B 买几个（这还算贪心吗）。后面遭不住了去看了一眼，算最低单价不就完事了。。。我是傻逼。



注意数据范围爆 int 

```cpp
#include <iostream>
#include <vector>

using namespace std;

int N, S;
long long res;

int main() {
    cin >> N >> S;
    
    long long res = 0;
    vector<int> prices(N, 0), want(N, 0);
    for (int i = 0; i < N; i++) {
        cin >> prices[i] >> want[i];
    }
    
    for (int i = 0; i < N; i++) {
        int minCost = prices[i];
        for (int j = 1; j <= i; j++) minCost = min(prices[i-j] + S*j, minCost);
        res += minCost * want[i];
    }

    cout << res << endl;
    return 0;
}
```



### Wireless Network

> F:Wireless Network
>
> 查看提交统计提问
>
> 总时间限制: 10000ms 内存限制: 65536kB
>
> 描述
>
> An earthquake takes place in Southeast Asia. The ACM (Asia Cooperated Medical team) have set up a wireless network with the lap computers, but an unexpected aftershock attacked, all computers in the network were all broken. The computers are repaired one by one, and the network gradually began to work again. Because of the hardware restricts, each computer can only directly communicate with the computers that are not farther than d meters from it. But every computer can be regarded as the intermediary of the communication between two other computers, that is to say computer A and computer B can communicate if computer A and computer B can communicate directly or there is a computer C that can communicate with both A and B.
>
> In the process of repairing the network, workers can take two kinds of operations at every moment, repairing a computer, or testing if two computers can communicate. Your job is to answer all the testing operations.
>
> 输入
>
> The first line contains two integers N and d (1 ≤ N ≤ 1001, 0 ≤ d ≤ 20000). Here N is the number of computers, which are numbered from 1 to N, and D is the maximum distance two computers can communicate directly. In the next N lines, each contains two integers xi, yi (0 ≤ xi, yi ≤ 10000), which is the coordinate of N computers. From the (N+1)-th line to the end of input, there are operations, which are carried out one by one. Each line contains an operation in one of following two formats:
>
> 1. "O p" (1 ≤ p ≤ N), which means repairing computer p.
> 2. "S p q" (1 ≤ p, q ≤ N), which means testing whether computer p and q can communicate.
>
> The input will not exceed 300000 lines.
>
> 输出
>
> For each Testing operation, print "SUCCESS" if the two computers can communicate, or "FAIL" if not.

这题很简单，图随便一下建模出来，但是一时间居然没想到用并查集来做，准备自己写链表了甚至。

```cpp
#include <iostream>
#include <unordered_set>
#include <cmath>
#include <vector>
using namespace std;

int find(vector<int>& p, int u) {
    if (p[u] != u) p[u] = find(p, p[u]);
    return p[u];
}

int main() {
    int n, d;
    cin >> n >> d;
    vector<vector<int>> mat(n + 1, vector<int>(2));
    vector<int> p(n+1);
    unordered_set<int> fixed;
    for (int i = 1; i <= n; i++) p[i] = i;
    for (int i = 1; i <= n; i++) {
        cin >> mat[i][0] >> mat[i][1];
    }

    char ch;
    while (cin >> ch) {
        int a, b;
        if (ch == 'O') {
            cin >> a;
            if (fixed.count(a)) continue;

            for (auto b: fixed) {
                int x = abs(mat[a][0] - mat[b][0]);
                int y = abs(mat[a][1] - mat[b][1]);
                int dst = x*x + y*y;
                if (dst <= d*d) {
                    p[find(p, b)] = find(p, a);
                }
            }
            

            fixed.insert(a);
        }
        else if (ch == 'S') {
            cin >> a >> b;
            if (find(p, a) == find(p, b)) {
                cout << "SUCCESS" << endl;
            }
            else {
                cout << "FAIL" << endl;
            }
        }
    }
}
```

### —— Summary

这次题非常简单，可以看到通过率都是 75%+。遇到这种题感觉还是得刷速度和熟练度。第七题是 KRUSKAL，由于 Yogurt Factory 浪费了一些时间，再加上下课了，所以没写，摆了。

后面要专门的练一练这些经典算法。
