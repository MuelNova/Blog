这篇博客记录了作者 nova 第一次尝试解决一个内核 PWN 题目，并详细描述了其过程和相关的技术细节。

### 前置知识
nova 介绍了在解决这个题目时所需的知识基础，其中包括 `seq_file` 机制和 KPTI（Kernel PageTable Isolation）。

**seq_file**：当在用户态执行 `open("/proc/self/stat",0);` 时，内核会分配一个 0x20 大小的 seq_operations 结构体，并通过特定指针（如 `start` 和 `stop`）调用相关函数。通过这些操作，可以泄露内核基址并控制程序流。

**KPTI**：Kernel PageTable Isolation 是通过隔离内核和用户空间页表来提高安全性。nova 详细介绍了如何切换页表以绕过 KPTI，进而通过 swapgs_restore_regs_and_return_to_usermode 方法恢复到用户态。

### 题目分析
nova 分析了题目提供的文件，包括内核映像和根文件系统。在分析驱动程序时，nova 发现了 ioctl 系统调用，它允许用户创建、释放和选择堆块，进而在堆块上进行读写操作。这揭示了一个关键点：通过特定顺序操作可以制造悬挂指针漏洞，进而控制内存内容。

### EXP 编写
为了实现目的，nova 使用 C 编写了 EXP 脚本。首先，保存用户态上下文，然后通过 seq_operations 结构体泄露内核基址。一旦内核基址泄露，nova 构建了一系列 ROP 链，通过控制程序流实现提权。

在 EXP 编写的过程中，nova 还解释了如何利用 `ioctl` 和 `read` 函数进行地址泄露和堆块控制，并通过修改指针构建漏洞利用场景。

### 总结
通过详细分析和逐步研究，nova 成功地构造了一条从泄露地址到实现提权的路径。这不仅是对特定题目的破解，也展示了内核 PWN 技术的实际应用。

nova 还提供了一些参考资料，供读者进一步了解相关技术和知识扩展。